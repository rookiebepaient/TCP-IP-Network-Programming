# 3.4 网络地址的初始化与分配
## 网络地址初始化
`sockaddr_in`结构体的初始化方法
```C++
struct sockaddr_in addr;
// 声明IP地址字符串
char *serv_ip = "211.217.168.12";
// 声明端口号字符串
char *serv_port = "9190";
// 结构体变量addr的所有成员初始化为0
memset(&addr, 0, sizeof(addr));
// 指定地址族
serv_addr.sin_family = AF_INET;
// 基于字符串的IP地址初始化
serv_addr.sin_addr.s_addr = htonl(serv_ip);
// 基于字符串的端口号初始化
serv_addr.sin_port = htons(atoi(serv_port));
```
## INADDR_ANY
```C++
struct sockaddr_in addr;
char *serv_port = "9190";
memset(&serv_addr, 0 , sizeof(serv_addr));
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
serv_addr.sin_port = htons(atoi(serv_port));
```
利用常数INADDR_ANY分配服务器端的IP地址。可以自动获取运行服务器端的计算机IP地址。若同一计算机中已分配多个IP地址(多宿主(`Multi-homed`)计算机，一般路由器属于这一类)，则只要端口号一致，就可以从不同IP地址接收数据。服务器端中优先考虑这种方式

## 向套接字分配网络地址
```C++
#include <sys/socket.h> // socket

/// @param[in] sockfd 要分配地址信息(IP地址和端口号)的套接字文件描述符
/// @param[in] myaddr 存有地址信息的结构体变量地址值
/// @param[in] addlen 第二个结构体变量的长度
/// @return 成功返回0，失败返回-1
int bind(int sockfd, struct sockaddr *myaddr, socklen_t addlen);

int serv_sock;
struct sockaddr_in serv_addr;

// 创建服务器端套接字 （监听套接字）
serv_sock = socket(PF_INET, SOCK_STREAM, 0);
// 地址信息初始化
memset(&serv_addr, 0 , sizeof(serv_addr));
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
serv_addr.sin_port = htons(atoi(argv[1]));
// 分配地址信息
bind(serv_sock, (struct sockaddr *) &serv_addr, sizeof(serv_addr))
```
