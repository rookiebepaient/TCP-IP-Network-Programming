# 10.2 进程和僵尸进程
## 僵尸进程
进程完成工作后(执行完mian函数中的程序后)应被销毁，但有时这些进程变成僵尸进程，占用系统中的重要资源。
## 产生僵尸进程的原因
调用fork函数产生子进程的终止方式
1. 传递参数并调用exie函数
2. main函数中执行return语句并返回值
向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统。直到把这些值传递给父进程，操作系统才会销毁子进程。处在这种状态下的进程就是僵尸进程。让子进程变成僵尸进程的是操作系统
向创建子进程的父进程传递子进程的exit参数值或return语句的返回值
如果父进程为主动要求获得子进程的结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸状态。所以说，要让父进程负责回收自己产生的子进程
## 销毁僵尸进程1：利用wait函数
```C++
#include <sys/wait.h>
// 成功返回终止的子进程ID，失败返回-1
pid_t wait(int *statloc)
```
函数参数所指向内存空间还有子进程终止时传递的返回值。需要通过以下宏来分离
`WIFEXIED` 子进程正常终止时返回 真
`WEXITSTATUS` 返回子进程的返回值
调用wait函数后，应编写以下代码
```C++
if (WIFEXITED(status)) {    //是否正常退出
    puts("正常退出");
    printf("Child pass num: %d", WEXITSTATUS(status));  // 返回值是多少
}
```
调用wait函数时，如果没有已终止的子进程，那么程序将阻塞到有子进程终止。
## 销毁僵尸线程2：使用waitpid函数
wait函数回引起程序阻塞，还可以考虑调用waitpid函数，可以防止阻塞
```C++
#include <sys/wait.h>
/// @param [in] pid, 等待终止的目标子进程ID，传递-1，则与wait函数相同，等待任意子进程终止
/// @param [in] statloc, 函数参数所指向内存空间还有子进程终止时传递的返回值
/// @param [in] opts 传递头文件sys/wait.h中声明的常量WNOHANG，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数
/// @return 成功返回终止的子进程ID，失败返回-1
pid_t waitpid(pid_t pid, int *statloc, int opts);
```