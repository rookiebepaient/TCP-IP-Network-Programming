# 关于IO流分离的内容
## 书中出现了两次IO流分离
1. TCP IO过程分离。通过fork函数复制出一个文件描述符，以区分输入和输出使用的文件描述符。文件描述符本身不会根据输入和输入进行区分，但是该方法区分了2个文件描述符的用途
2. 通过调用fdopen函数的调用，创建读模式FILE指针（FILE结构体指针）和写模式FILE指针。该方法分离了输入工具和输出工具
## 分离流的好处
IO过程分离：
1. 通过分开输入过程（代码）和输出过程降低实现难度
2. 与输入无关的输出操作可以提高速度
工具分离：
1. 为了将FILE指针按读模式和写模式加以区分
2. 可以通过区s分读写模式降低实现难度
3. 通过区分IO缓冲提高缓冲性能
## 终止流时无法半关闭的原因
FILE write_ptr <-|
                 |-> File Descriptor <---> socket
FIlE read_ptr  <-|
读写模式的FILE指针都是基于同一个文件描述符创建的。因此，针对任意一个FILE指针调用fclose函数都会关闭文件描述符，也就终止了套接字
销毁套接字时就无法进行数据的交换。如何进入可以输入但是无法输出的半关闭状态呢？
可以在创建FILE指针前复制文件描述符
FILE write_ptr <--> File Descriptor <-|
                           ↓          |--> socket
FIlE read_ptr  <--> File Descriptor <-|
复制后另外创建一个文件描述符，利用各自的文件描述符生成读模式和写模式FILE指针。
这样就为半关闭准备好了环境，因为套接字和文件描述符具有如下的关系
销毁所有文件描述符后才能销毁套接字
也就是说，针对写模式FILE指针调用fclose函数时，只能销毁与该FILE指针相关的文件描述符，无法销毁套接字。
调用fclose函数后还剩一个文件描述符，因此没有销毁套接字，但此时并不是半关闭状态。只是准备好了半关闭环境，真正进入半关闭状态需要特殊处理

## 复制文件描述符
在同一个进程中完成描述符的复制
复制的含义为：
为了访问同一文件或套接字，创建另一个文件描述符
所以复制出的文件描述符的值是不同的
```C++
#include <unistd.h>

int dup(int files);
/**
 * fildes 需要复制的文件描述符
 * fildes2 明确指定的文件描述符整数值
 * 成功时返回复制的文件描述符，失败时返回-1
*/
int dup2(int fildes, int fildes2);
```