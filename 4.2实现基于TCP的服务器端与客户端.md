# 4.2 实现基于TCP的服务器端与客户端
## TCP服务器端的默认函数调用顺序
`socket()`创建套接字
        ↓ 
`bind()`分配套接字地址
        ↓
`listen()`创建套接字
        ↓
`accept()`允许连接
        ↓
`read()/write()`数据交换
        ↓
`close()`断开连接

## 进入等待连接请求状态
```C++
#include <sys/socket.h>

/// @param [in] sock 服务器端的监听套接字
/// @param [in] bakclog 连接请求等待队列的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列
/// @return 
int listen(int sock, int backlog);
```

## 受理客户端连接请求
```C++
#include <sys/socket.h>

/// @param[in] sockfd 服务器的套接字文件描述符
/// @param[in] addr 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息
/// @param[in] addlen 第二个结构体变量的长度，但是是存有长度的变量地址。函数调用完后，该变量即被填入客户端地址长度
/// @return 成功返回0，失败返回-1
int accept(int sock, struct sockaddr *addr, socklen_t addlen);
```

## TCP客户端的默认函数调用顺序
```C++
#include <sys/socket.h> // socket

/// @param[in] sockfd 客户端的套接字文件描述符
/// @param[in] myaddr 存有目标服务器地址信息的变量地址值
/// @param[in] addlen 第二个结构体变量的长度
/// @return 成功返回0，失败返回-1
int bind(int sockfd, struct sockaddr *myaddr, socklen_t addlen);
```
客户端调用`connect`函数后，发生以下情况之一才会返回（完成函数调用）
1. 服务器端接受连接请求，接受连接并不意味着服务器端调用accept函数，是服务器端把连接请求信息记录到等待队列，因此`connect`函数返回后不立即进行数据交换
2. 发生断网等异常情况而中断连接请求